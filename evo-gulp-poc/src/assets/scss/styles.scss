////
/// @group menu-bar
////

/// Default margin of a menu bar.
/// @type Number
$menubar-margin: 0 !default;

/// Default background color of a menu bar.
/// @type Color
$menubar-background: transparent;

/// Default text color for items in a menu bar.
/// @type Color
$menubar-item-color: foreground($menubar-background, $primary-color);

/// Default background color on hover for items in a menu bar.
$menubar-item-background-hover: #eee !default;

/// Default padding for items in a menu bar.
/// @type Number
$menubar-item-padding: 0.7rem 1rem !default;

/// Default spacing between an icon and text in a menu bar item.
/// @type Number
$menubar-icon-spacing: 0.25rem !default;

/// Maximum number of `expand-n` classes to include in the CSS.
/// @type Number
$menubar-expand-max: 6 !default;

/// Creates the base styles for a menu bar.
@mixin menu-bar-base() {
  @include clearfix;
  margin: $menubar-margin;
  list-style-type: none;

  // Hover/active state
  > .is-active > a {
    background: $menubar-item-background-hover;
  }

  // Default
  > li > a {
    display: block;
    padding: $menubar-item-padding;
    line-height: 1;
    color: $menubar-item-color;

    &:hover,
    &:focus {
      background: $menubar-item-background-hover;
    }
  }
}

/// Expands the items of a menu bar, so each item is the same width.
/// @param {Keyword|Number} $count [auto] - Number of items in the menu bar. You can hardcode a number, or use `auto` to generate CSS that will adapt to the number of items inside the menu.
@mixin menu-bar-expand($count: auto) {
  > li {
    @if $count == auto {
      @for $i from 2 through $menubar-expand-max {
        &:nth-last-child(#{$i}):first-child,
        &:nth-last-child(#{$i}):first-child ~ li {
          width: percentage(1 / $i);
        }
      }
    }
    @else if type-of($count) == 'number' {
      width: percentage(1 / $count);
    }
  }
}

/// Sets the direction of a menu bar.
/// @param {Keyword} $dir [horizontal] - Direction of the menu bar. Can be `horizontal` or `vertical`.
@mixin menu-bar-direction($dir: horizontal) {
  @if $dir == horizontal {
    > li {
      float: left;
    }
  }
  @else if $dir == vertical {
    > li {
      width: 100%;
      float: none;
    }
  }
  @else {
    @debug "The direction used for menu-bar-direction() must be horizontal or vertical.";
  }
}

/// Creates a simple menu bar, which has no padding or hover state.
@mixin menu-bar-simple {
  > li > a {
    padding: 0;
    margin-right: get-side($menubar-item-padding, right);

    &:hover {
      background: transparent;
    }
  }
}

/// Adds styles for a nested menu bar. You can pass in a padding amount, which will be applied to the left (or right in RTL) of each item in the menu bar.
/// @param {Keyword|Number} $padding [auto] - Amount of padding to apply. Use `auto` to apply twice the padding of a normal menu bar item.
@mixin menu-bar-nested($padding: auto) {
  > li > a {
    $padding-left: 0;

    @if $padding == auto {
      $padding-left: get-side($menubar-item-padding, left) * 2;
    }
    @else {
      $padding-left: $padding;
    }

    padding-left: $padding-left;
  }
}

/// Changes the default colors of a menu bar.
@mixin menu-bar-style {
  background: $primary-color;

  > li > a {
    color: foreground($primary-color);

    &:hover,
    &:focus {
      background: smart-scale($primary-color);
    }
  }
}

/// Adds support for icons to menu bar items.
/// @param {Keyword} $position [side] - Positioning for icons. Can be `side` (left, or right on RTL) or `top`.
/// @param {Boolean} $base [true] - Set to `false` to prevent the shared CSS between side- and top-aligned icons from being printed. Set this to `false` if you're calling the mixin multiple times on the same element.
@mixin menu-bar-icons($position: side, $base: true) {
  @if $base {
    > li > a, {
      > img,
      > i {
        vertical-align: middle;
      }
      > span {
        vertical-align: middle;
      }
    }
  }

  @if $position == side {
    > li > a {
      > img,
      > i {
        display: inline-block;
        margin-right: $menubar-icon-spacing;
      }
    }
  }
  @else if $position == top {
    > li > a {
      text-align: center;

      > img,
      > i {
        display: block;
        margin: 0 auto $menubar-icon-spacing auto;
      }
    }
  }
}

.menu-bar {
  @include menu-bar-base;

  // Orientation
  @include menu-bar-direction(horizontal);

  &.vertical {
    @include menu-bar-direction(vertical);
  }

  @each $size in $breakpoint-classes {
    @if $size != small {
      &.#{$size}-horizontal {
        @include menu-bar-direction(horizontal);
      }
      &.#{$size}-vertical {
        @include menu-bar-direction(vertical);
      }
    }
  }

  // Simple
  &.simple {
    @include menu-bar-simple;
  }

  // Align right
  &.align-right {
    > li {
      float: right;
    }
  }

  // Even-width
  &.expand {
    @include menu-bar-expand;

    > li {
      &:first-child:last-child {
        width: 100%;
      }
    }
  }

  // Primary color
  &.primary {
    @include menu-bar-style;
  }

  // Icons
  @include menu-bar-icons;

  // Vertical icons
  &.icon-top {
    @include menu-bar-icons(top, $base: false);
  }

  // Nesting
  &.nested {
    @include menu-bar-nested;
  }
}


// REM CALC
// ------------------------------------------------------------------------------------------
// Foundation for Sites by ZURB
// foundation.zurb.com
// Licensed under MIT Open Source

$global-font-size: 100%;

// scss-lint:disable ZeroUnit

/// Removes the unit (e.g. px, em, rem) from a value, returning the number only.
///
/// @param {Number} $num - Number to strip unit from.
///
/// @returns {Number} The same number, sans unit.
@function strip-unit($num) {
  @return $num / ($num * 0 + 1);
}

/// Converts one or more pixel values into matching rem values.
///
/// @param {Number|List} $values - One or more values to convert. Be sure to separate them with spaces and not commas. If you need to convert a comma-separated list, wrap the list in parentheses.
/// @param {Number} $base [null] - The base value to use when calculating the `rem`. If you're using Foundation out of the box, this is 16px. If this parameter is `null`, the function will reference the `$base-font-size` variable as the base.
///
/// @returns {List} A list of converted values.
@function rem-calc($values, $base: null) {
  $rem-values: ();
  $count: length($values);

  // If no base is defined, defer to the global font size
  @if $base == null {
    $base: $global-font-size;
  }

  // If the base font size is a %, then multiply it by 16px
  // This is because 100% font size = 16px in most all browsers
  @if unit($base) == '%' {
    $base: ($base / 100%) * 16px;
  }

  @if $count == 1 {
    @return -zf-to-rem($values, $base);
  }

  @for $i from 1 through $count {
    $rem-values: append($rem-values, -zf-to-rem(nth($values, $i), $base));
  }

  @return $rem-values;
}

// Converts a unitless, pixel, or rem value to em, for use in breakpoints.
@function -zf-bp-to-em($value) {
  // Pixel and unitless values are converted to rems
  @if unit($value) == 'px' or unitless($value) {
    $value: rem-calc($value, $base: 16px);
  }

  // Then the value is converted to ems
  @return strip-unit($value) * 1em;
}

/// Converts a pixel value to matching rem value. *Any* value passed, regardless of unit, is assumed to be a pixel value. By default, the base pixel value used to calculate the rem value is taken from the `$global-font-size` variable.
/// @access private
///
/// @param {Number} $value - Pixel value to convert.
/// @param {Number} $base [null] - Base for pixel conversion.
///
/// @returns {Number} A number in rems, calculated based on the given value and the base pixel value. rem values are passed through as is.
@function -zf-to-rem($value, $base: null) {
  // Check if the value is a number
  @if type-of($value) != 'number' {
    @warn inspect($value) + ' was passed to rem-calc(), which is not a number.';
    @return $value;
  }

  // Calculate rem if units for $value is not rem
  @if unit($value) != 'rem' {
    $value: strip-unit($value) / strip-unit($base) * 1rem;
  }

  // Turn 0rem into 0
  @if $value == 0rem {
    $value: 0;
  }

  @return $value;
}